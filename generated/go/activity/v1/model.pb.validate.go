// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: activity/v1/model.proto

package activitypb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	poolpb "github.com/code-payments/flipcash-protobuf-api/generated/go/pool/v1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = poolpb.UserOutcome(0)
)

// Validate checks the field values on NotificationId with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NotificationId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NotificationId with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NotificationIdMultiError,
// or nil if none found.
func (m *NotificationId) ValidateAll() error {
	return m.validate(true)
}

func (m *NotificationId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetValue()) != 32 {
		err := NotificationIdValidationError{
			field:  "Value",
			reason: "value length must be 32 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return NotificationIdMultiError(errors)
	}

	return nil
}

// NotificationIdMultiError is an error wrapping multiple validation errors
// returned by NotificationId.ValidateAll() if the designated constraints
// aren't met.
type NotificationIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotificationIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotificationIdMultiError) AllErrors() []error { return m }

// NotificationIdValidationError is the validation error returned by
// NotificationId.Validate if the designated constraints aren't met.
type NotificationIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotificationIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotificationIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotificationIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotificationIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotificationIdValidationError) ErrorName() string { return "NotificationIdValidationError" }

// Error satisfies the builtin error interface
func (e NotificationIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotificationId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotificationIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotificationIdValidationError{}

// Validate checks the field values on Notification with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Notification) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Notification with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NotificationMultiError, or
// nil if none found.
func (m *Notification) ValidateAll() error {
	return m.validate(true)
}

func (m *Notification) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() == nil {
		err := NotificationValidationError{
			field:  "Id",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotificationValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotificationValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotificationValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetLocalizedText()); l < 1 || l > 256 {
		err := NotificationValidationError{
			field:  "LocalizedText",
			reason: "value length must be between 1 and 256 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPaymentAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotificationValidationError{
					field:  "PaymentAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotificationValidationError{
					field:  "PaymentAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaymentAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotificationValidationError{
				field:  "PaymentAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetTs() == nil {
		err := NotificationValidationError{
			field:  "Ts",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _Notification_State_NotInLookup[m.GetState()]; ok {
		err := NotificationValidationError{
			field:  "State",
			reason: "value must not be in list [NOTIFICATION_STATE_UNKNOWN]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	switch v := m.AdditionalMetadata.(type) {
	case *Notification_WelcomeBonus:
		if v == nil {
			err := NotificationValidationError{
				field:  "AdditionalMetadata",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetWelcomeBonus()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NotificationValidationError{
						field:  "WelcomeBonus",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NotificationValidationError{
						field:  "WelcomeBonus",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWelcomeBonus()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NotificationValidationError{
					field:  "WelcomeBonus",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Notification_GaveCrypto:
		if v == nil {
			err := NotificationValidationError{
				field:  "AdditionalMetadata",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGaveCrypto()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NotificationValidationError{
						field:  "GaveCrypto",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NotificationValidationError{
						field:  "GaveCrypto",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGaveCrypto()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NotificationValidationError{
					field:  "GaveCrypto",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Notification_ReceivedCrypto:
		if v == nil {
			err := NotificationValidationError{
				field:  "AdditionalMetadata",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReceivedCrypto()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NotificationValidationError{
						field:  "ReceivedCrypto",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NotificationValidationError{
						field:  "ReceivedCrypto",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReceivedCrypto()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NotificationValidationError{
					field:  "ReceivedCrypto",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Notification_WithdrewCrypto:
		if v == nil {
			err := NotificationValidationError{
				field:  "AdditionalMetadata",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetWithdrewCrypto()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NotificationValidationError{
						field:  "WithdrewCrypto",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NotificationValidationError{
						field:  "WithdrewCrypto",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWithdrewCrypto()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NotificationValidationError{
					field:  "WithdrewCrypto",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Notification_SentCrypto:
		if v == nil {
			err := NotificationValidationError{
				field:  "AdditionalMetadata",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSentCrypto()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NotificationValidationError{
						field:  "SentCrypto",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NotificationValidationError{
						field:  "SentCrypto",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSentCrypto()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NotificationValidationError{
					field:  "SentCrypto",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Notification_DepositedCrypto:
		if v == nil {
			err := NotificationValidationError{
				field:  "AdditionalMetadata",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDepositedCrypto()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NotificationValidationError{
						field:  "DepositedCrypto",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NotificationValidationError{
						field:  "DepositedCrypto",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDepositedCrypto()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NotificationValidationError{
					field:  "DepositedCrypto",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Notification_PaidCrypto:
		if v == nil {
			err := NotificationValidationError{
				field:  "AdditionalMetadata",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPaidCrypto()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NotificationValidationError{
						field:  "PaidCrypto",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NotificationValidationError{
						field:  "PaidCrypto",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPaidCrypto()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NotificationValidationError{
					field:  "PaidCrypto",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Notification_DistributedCrypto:
		if v == nil {
			err := NotificationValidationError{
				field:  "AdditionalMetadata",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDistributedCrypto()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NotificationValidationError{
						field:  "DistributedCrypto",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NotificationValidationError{
						field:  "DistributedCrypto",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDistributedCrypto()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NotificationValidationError{
					field:  "DistributedCrypto",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return NotificationMultiError(errors)
	}

	return nil
}

// NotificationMultiError is an error wrapping multiple validation errors
// returned by Notification.ValidateAll() if the designated constraints aren't met.
type NotificationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotificationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotificationMultiError) AllErrors() []error { return m }

// NotificationValidationError is the validation error returned by
// Notification.Validate if the designated constraints aren't met.
type NotificationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotificationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotificationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotificationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotificationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotificationValidationError) ErrorName() string { return "NotificationValidationError" }

// Error satisfies the builtin error interface
func (e NotificationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotification.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotificationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotificationValidationError{}

var _Notification_State_NotInLookup = map[NotificationState]struct{}{
	0: {},
}

// Validate checks the field values on WelcomeBonusNotificationMetadata with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *WelcomeBonusNotificationMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WelcomeBonusNotificationMetadata with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// WelcomeBonusNotificationMetadataMultiError, or nil if none found.
func (m *WelcomeBonusNotificationMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *WelcomeBonusNotificationMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return WelcomeBonusNotificationMetadataMultiError(errors)
	}

	return nil
}

// WelcomeBonusNotificationMetadataMultiError is an error wrapping multiple
// validation errors returned by
// WelcomeBonusNotificationMetadata.ValidateAll() if the designated
// constraints aren't met.
type WelcomeBonusNotificationMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WelcomeBonusNotificationMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WelcomeBonusNotificationMetadataMultiError) AllErrors() []error { return m }

// WelcomeBonusNotificationMetadataValidationError is the validation error
// returned by WelcomeBonusNotificationMetadata.Validate if the designated
// constraints aren't met.
type WelcomeBonusNotificationMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WelcomeBonusNotificationMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WelcomeBonusNotificationMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WelcomeBonusNotificationMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WelcomeBonusNotificationMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WelcomeBonusNotificationMetadataValidationError) ErrorName() string {
	return "WelcomeBonusNotificationMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e WelcomeBonusNotificationMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWelcomeBonusNotificationMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WelcomeBonusNotificationMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WelcomeBonusNotificationMetadataValidationError{}

// Validate checks the field values on GaveCryptoNotificationMetadata with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GaveCryptoNotificationMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GaveCryptoNotificationMetadata with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GaveCryptoNotificationMetadataMultiError, or nil if none found.
func (m *GaveCryptoNotificationMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *GaveCryptoNotificationMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GaveCryptoNotificationMetadataMultiError(errors)
	}

	return nil
}

// GaveCryptoNotificationMetadataMultiError is an error wrapping multiple
// validation errors returned by GaveCryptoNotificationMetadata.ValidateAll()
// if the designated constraints aren't met.
type GaveCryptoNotificationMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GaveCryptoNotificationMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GaveCryptoNotificationMetadataMultiError) AllErrors() []error { return m }

// GaveCryptoNotificationMetadataValidationError is the validation error
// returned by GaveCryptoNotificationMetadata.Validate if the designated
// constraints aren't met.
type GaveCryptoNotificationMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GaveCryptoNotificationMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GaveCryptoNotificationMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GaveCryptoNotificationMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GaveCryptoNotificationMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GaveCryptoNotificationMetadataValidationError) ErrorName() string {
	return "GaveCryptoNotificationMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e GaveCryptoNotificationMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGaveCryptoNotificationMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GaveCryptoNotificationMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GaveCryptoNotificationMetadataValidationError{}

// Validate checks the field values on ReceivedCryptoNotificationMetadata with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ReceivedCryptoNotificationMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReceivedCryptoNotificationMetadata
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ReceivedCryptoNotificationMetadataMultiError, or nil if none found.
func (m *ReceivedCryptoNotificationMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *ReceivedCryptoNotificationMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ReceivedCryptoNotificationMetadataMultiError(errors)
	}

	return nil
}

// ReceivedCryptoNotificationMetadataMultiError is an error wrapping multiple
// validation errors returned by
// ReceivedCryptoNotificationMetadata.ValidateAll() if the designated
// constraints aren't met.
type ReceivedCryptoNotificationMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReceivedCryptoNotificationMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReceivedCryptoNotificationMetadataMultiError) AllErrors() []error { return m }

// ReceivedCryptoNotificationMetadataValidationError is the validation error
// returned by ReceivedCryptoNotificationMetadata.Validate if the designated
// constraints aren't met.
type ReceivedCryptoNotificationMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReceivedCryptoNotificationMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReceivedCryptoNotificationMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReceivedCryptoNotificationMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReceivedCryptoNotificationMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReceivedCryptoNotificationMetadataValidationError) ErrorName() string {
	return "ReceivedCryptoNotificationMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e ReceivedCryptoNotificationMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReceivedCryptoNotificationMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReceivedCryptoNotificationMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReceivedCryptoNotificationMetadataValidationError{}

// Validate checks the field values on WithdrewCryptoNotificationMetadata with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *WithdrewCryptoNotificationMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WithdrewCryptoNotificationMetadata
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// WithdrewCryptoNotificationMetadataMultiError, or nil if none found.
func (m *WithdrewCryptoNotificationMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *WithdrewCryptoNotificationMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return WithdrewCryptoNotificationMetadataMultiError(errors)
	}

	return nil
}

// WithdrewCryptoNotificationMetadataMultiError is an error wrapping multiple
// validation errors returned by
// WithdrewCryptoNotificationMetadata.ValidateAll() if the designated
// constraints aren't met.
type WithdrewCryptoNotificationMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WithdrewCryptoNotificationMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WithdrewCryptoNotificationMetadataMultiError) AllErrors() []error { return m }

// WithdrewCryptoNotificationMetadataValidationError is the validation error
// returned by WithdrewCryptoNotificationMetadata.Validate if the designated
// constraints aren't met.
type WithdrewCryptoNotificationMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WithdrewCryptoNotificationMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WithdrewCryptoNotificationMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WithdrewCryptoNotificationMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WithdrewCryptoNotificationMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WithdrewCryptoNotificationMetadataValidationError) ErrorName() string {
	return "WithdrewCryptoNotificationMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e WithdrewCryptoNotificationMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWithdrewCryptoNotificationMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WithdrewCryptoNotificationMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WithdrewCryptoNotificationMetadataValidationError{}

// Validate checks the field values on SentCryptoNotificationMetadata with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SentCryptoNotificationMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SentCryptoNotificationMetadata with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SentCryptoNotificationMetadataMultiError, or nil if none found.
func (m *SentCryptoNotificationMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *SentCryptoNotificationMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetVault() == nil {
		err := SentCryptoNotificationMetadataValidationError{
			field:  "Vault",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetVault()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SentCryptoNotificationMetadataValidationError{
					field:  "Vault",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SentCryptoNotificationMetadataValidationError{
					field:  "Vault",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVault()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SentCryptoNotificationMetadataValidationError{
				field:  "Vault",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CanInitiateCancelAction

	if len(errors) > 0 {
		return SentCryptoNotificationMetadataMultiError(errors)
	}

	return nil
}

// SentCryptoNotificationMetadataMultiError is an error wrapping multiple
// validation errors returned by SentCryptoNotificationMetadata.ValidateAll()
// if the designated constraints aren't met.
type SentCryptoNotificationMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SentCryptoNotificationMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SentCryptoNotificationMetadataMultiError) AllErrors() []error { return m }

// SentCryptoNotificationMetadataValidationError is the validation error
// returned by SentCryptoNotificationMetadata.Validate if the designated
// constraints aren't met.
type SentCryptoNotificationMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SentCryptoNotificationMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SentCryptoNotificationMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SentCryptoNotificationMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SentCryptoNotificationMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SentCryptoNotificationMetadataValidationError) ErrorName() string {
	return "SentCryptoNotificationMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e SentCryptoNotificationMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSentCryptoNotificationMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SentCryptoNotificationMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SentCryptoNotificationMetadataValidationError{}

// Validate checks the field values on DepositedCryptoNotificationMetadata with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DepositedCryptoNotificationMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DepositedCryptoNotificationMetadata
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DepositedCryptoNotificationMetadataMultiError, or nil if none found.
func (m *DepositedCryptoNotificationMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *DepositedCryptoNotificationMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DepositedCryptoNotificationMetadataMultiError(errors)
	}

	return nil
}

// DepositedCryptoNotificationMetadataMultiError is an error wrapping multiple
// validation errors returned by
// DepositedCryptoNotificationMetadata.ValidateAll() if the designated
// constraints aren't met.
type DepositedCryptoNotificationMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DepositedCryptoNotificationMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DepositedCryptoNotificationMetadataMultiError) AllErrors() []error { return m }

// DepositedCryptoNotificationMetadataValidationError is the validation error
// returned by DepositedCryptoNotificationMetadata.Validate if the designated
// constraints aren't met.
type DepositedCryptoNotificationMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DepositedCryptoNotificationMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DepositedCryptoNotificationMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DepositedCryptoNotificationMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DepositedCryptoNotificationMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DepositedCryptoNotificationMetadataValidationError) ErrorName() string {
	return "DepositedCryptoNotificationMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e DepositedCryptoNotificationMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDepositedCryptoNotificationMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DepositedCryptoNotificationMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DepositedCryptoNotificationMetadataValidationError{}

// Validate checks the field values on PaidCryptoNotificationMetadata with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PaidCryptoNotificationMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PaidCryptoNotificationMetadata with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// PaidCryptoNotificationMetadataMultiError, or nil if none found.
func (m *PaidCryptoNotificationMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *PaidCryptoNotificationMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofPaymentMetadataPresent := false
	switch v := m.PaymentMetadata.(type) {
	case *PaidCryptoNotificationMetadata_Pool:
		if v == nil {
			err := PaidCryptoNotificationMetadataValidationError{
				field:  "PaymentMetadata",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofPaymentMetadataPresent = true

		if all {
			switch v := interface{}(m.GetPool()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PaidCryptoNotificationMetadataValidationError{
						field:  "Pool",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PaidCryptoNotificationMetadataValidationError{
						field:  "Pool",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPool()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PaidCryptoNotificationMetadataValidationError{
					field:  "Pool",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofPaymentMetadataPresent {
		err := PaidCryptoNotificationMetadataValidationError{
			field:  "PaymentMetadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PaidCryptoNotificationMetadataMultiError(errors)
	}

	return nil
}

// PaidCryptoNotificationMetadataMultiError is an error wrapping multiple
// validation errors returned by PaidCryptoNotificationMetadata.ValidateAll()
// if the designated constraints aren't met.
type PaidCryptoNotificationMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaidCryptoNotificationMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaidCryptoNotificationMetadataMultiError) AllErrors() []error { return m }

// PaidCryptoNotificationMetadataValidationError is the validation error
// returned by PaidCryptoNotificationMetadata.Validate if the designated
// constraints aren't met.
type PaidCryptoNotificationMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaidCryptoNotificationMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PaidCryptoNotificationMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PaidCryptoNotificationMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PaidCryptoNotificationMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaidCryptoNotificationMetadataValidationError) ErrorName() string {
	return "PaidCryptoNotificationMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e PaidCryptoNotificationMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaidCryptoNotificationMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaidCryptoNotificationMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaidCryptoNotificationMetadataValidationError{}

// Validate checks the field values on DistributedCryptoNotificationMetadata
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *DistributedCryptoNotificationMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DistributedCryptoNotificationMetadata
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DistributedCryptoNotificationMetadataMultiError, or nil if none found.
func (m *DistributedCryptoNotificationMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *DistributedCryptoNotificationMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofDistributionMetadataPresent := false
	switch v := m.DistributionMetadata.(type) {
	case *DistributedCryptoNotificationMetadata_Pool:
		if v == nil {
			err := DistributedCryptoNotificationMetadataValidationError{
				field:  "DistributionMetadata",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofDistributionMetadataPresent = true

		if all {
			switch v := interface{}(m.GetPool()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DistributedCryptoNotificationMetadataValidationError{
						field:  "Pool",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DistributedCryptoNotificationMetadataValidationError{
						field:  "Pool",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPool()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DistributedCryptoNotificationMetadataValidationError{
					field:  "Pool",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofDistributionMetadataPresent {
		err := DistributedCryptoNotificationMetadataValidationError{
			field:  "DistributionMetadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DistributedCryptoNotificationMetadataMultiError(errors)
	}

	return nil
}

// DistributedCryptoNotificationMetadataMultiError is an error wrapping
// multiple validation errors returned by
// DistributedCryptoNotificationMetadata.ValidateAll() if the designated
// constraints aren't met.
type DistributedCryptoNotificationMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DistributedCryptoNotificationMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DistributedCryptoNotificationMetadataMultiError) AllErrors() []error { return m }

// DistributedCryptoNotificationMetadataValidationError is the validation error
// returned by DistributedCryptoNotificationMetadata.Validate if the
// designated constraints aren't met.
type DistributedCryptoNotificationMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DistributedCryptoNotificationMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DistributedCryptoNotificationMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DistributedCryptoNotificationMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DistributedCryptoNotificationMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DistributedCryptoNotificationMetadataValidationError) ErrorName() string {
	return "DistributedCryptoNotificationMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e DistributedCryptoNotificationMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDistributedCryptoNotificationMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DistributedCryptoNotificationMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DistributedCryptoNotificationMetadataValidationError{}

// Validate checks the field values on
// PaidCryptoNotificationMetadata_PoolPaymentMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PaidCryptoNotificationMetadata_PoolPaymentMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// PaidCryptoNotificationMetadata_PoolPaymentMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// PaidCryptoNotificationMetadata_PoolPaymentMetadataMultiError, or nil if
// none found.
func (m *PaidCryptoNotificationMetadata_PoolPaymentMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *PaidCryptoNotificationMetadata_PoolPaymentMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPoolId() == nil {
		err := PaidCryptoNotificationMetadata_PoolPaymentMetadataValidationError{
			field:  "PoolId",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPoolId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PaidCryptoNotificationMetadata_PoolPaymentMetadataValidationError{
					field:  "PoolId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PaidCryptoNotificationMetadata_PoolPaymentMetadataValidationError{
					field:  "PoolId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPoolId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PaidCryptoNotificationMetadata_PoolPaymentMetadataValidationError{
				field:  "PoolId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PaidCryptoNotificationMetadata_PoolPaymentMetadataMultiError(errors)
	}

	return nil
}

// PaidCryptoNotificationMetadata_PoolPaymentMetadataMultiError is an error
// wrapping multiple validation errors returned by
// PaidCryptoNotificationMetadata_PoolPaymentMetadata.ValidateAll() if the
// designated constraints aren't met.
type PaidCryptoNotificationMetadata_PoolPaymentMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PaidCryptoNotificationMetadata_PoolPaymentMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PaidCryptoNotificationMetadata_PoolPaymentMetadataMultiError) AllErrors() []error { return m }

// PaidCryptoNotificationMetadata_PoolPaymentMetadataValidationError is the
// validation error returned by
// PaidCryptoNotificationMetadata_PoolPaymentMetadata.Validate if the
// designated constraints aren't met.
type PaidCryptoNotificationMetadata_PoolPaymentMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PaidCryptoNotificationMetadata_PoolPaymentMetadataValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e PaidCryptoNotificationMetadata_PoolPaymentMetadataValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e PaidCryptoNotificationMetadata_PoolPaymentMetadataValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e PaidCryptoNotificationMetadata_PoolPaymentMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PaidCryptoNotificationMetadata_PoolPaymentMetadataValidationError) ErrorName() string {
	return "PaidCryptoNotificationMetadata_PoolPaymentMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e PaidCryptoNotificationMetadata_PoolPaymentMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPaidCryptoNotificationMetadata_PoolPaymentMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PaidCryptoNotificationMetadata_PoolPaymentMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PaidCryptoNotificationMetadata_PoolPaymentMetadataValidationError{}

// Validate checks the field values on
// DistributedCryptoNotificationMetadata_PoolDistributionMetadata with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DistributedCryptoNotificationMetadata_PoolDistributionMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// DistributedCryptoNotificationMetadata_PoolDistributionMetadata with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DistributedCryptoNotificationMetadata_PoolDistributionMetadataMultiError,
// or nil if none found.
func (m *DistributedCryptoNotificationMetadata_PoolDistributionMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *DistributedCryptoNotificationMetadata_PoolDistributionMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPoolId() == nil {
		err := DistributedCryptoNotificationMetadata_PoolDistributionMetadataValidationError{
			field:  "PoolId",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPoolId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DistributedCryptoNotificationMetadata_PoolDistributionMetadataValidationError{
					field:  "PoolId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DistributedCryptoNotificationMetadata_PoolDistributionMetadataValidationError{
					field:  "PoolId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPoolId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DistributedCryptoNotificationMetadata_PoolDistributionMetadataValidationError{
				field:  "PoolId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if _, ok := _DistributedCryptoNotificationMetadata_PoolDistributionMetadata_Outcome_InLookup[m.GetOutcome()]; !ok {
		err := DistributedCryptoNotificationMetadata_PoolDistributionMetadataValidationError{
			field:  "Outcome",
			reason: "value must be in list [WIN_OUTCOME REFUND_OUTCOME]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DistributedCryptoNotificationMetadata_PoolDistributionMetadataMultiError(errors)
	}

	return nil
}

// DistributedCryptoNotificationMetadata_PoolDistributionMetadataMultiError is
// an error wrapping multiple validation errors returned by
// DistributedCryptoNotificationMetadata_PoolDistributionMetadata.ValidateAll()
// if the designated constraints aren't met.
type DistributedCryptoNotificationMetadata_PoolDistributionMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DistributedCryptoNotificationMetadata_PoolDistributionMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DistributedCryptoNotificationMetadata_PoolDistributionMetadataMultiError) AllErrors() []error {
	return m
}

// DistributedCryptoNotificationMetadata_PoolDistributionMetadataValidationError
// is the validation error returned by
// DistributedCryptoNotificationMetadata_PoolDistributionMetadata.Validate if
// the designated constraints aren't met.
type DistributedCryptoNotificationMetadata_PoolDistributionMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DistributedCryptoNotificationMetadata_PoolDistributionMetadataValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e DistributedCryptoNotificationMetadata_PoolDistributionMetadataValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e DistributedCryptoNotificationMetadata_PoolDistributionMetadataValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e DistributedCryptoNotificationMetadata_PoolDistributionMetadataValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e DistributedCryptoNotificationMetadata_PoolDistributionMetadataValidationError) ErrorName() string {
	return "DistributedCryptoNotificationMetadata_PoolDistributionMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e DistributedCryptoNotificationMetadata_PoolDistributionMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDistributedCryptoNotificationMetadata_PoolDistributionMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DistributedCryptoNotificationMetadata_PoolDistributionMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DistributedCryptoNotificationMetadata_PoolDistributionMetadataValidationError{}

var _DistributedCryptoNotificationMetadata_PoolDistributionMetadata_Outcome_InLookup = map[poolpb.UserOutcome]struct{}{
	2: {},
	4: {},
}
