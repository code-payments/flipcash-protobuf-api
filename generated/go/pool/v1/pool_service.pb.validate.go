// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: pool/v1/pool_service.proto

package poolpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CreatePoolRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreatePoolRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePoolRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePoolRequestMultiError, or nil if none found.
func (m *CreatePoolRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePoolRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPool() == nil {
		err := CreatePoolRequestValidationError{
			field:  "Pool",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPool()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePoolRequestValidationError{
					field:  "Pool",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePoolRequestValidationError{
					field:  "Pool",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPool()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePoolRequestValidationError{
				field:  "Pool",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetRendezvousSignature() == nil {
		err := CreatePoolRequestValidationError{
			field:  "RendezvousSignature",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRendezvousSignature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePoolRequestValidationError{
					field:  "RendezvousSignature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePoolRequestValidationError{
					field:  "RendezvousSignature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRendezvousSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePoolRequestValidationError{
				field:  "RendezvousSignature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetAuth() == nil {
		err := CreatePoolRequestValidationError{
			field:  "Auth",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePoolRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePoolRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePoolRequestValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreatePoolRequestMultiError(errors)
	}

	return nil
}

// CreatePoolRequestMultiError is an error wrapping multiple validation errors
// returned by CreatePoolRequest.ValidateAll() if the designated constraints
// aren't met.
type CreatePoolRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePoolRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePoolRequestMultiError) AllErrors() []error { return m }

// CreatePoolRequestValidationError is the validation error returned by
// CreatePoolRequest.Validate if the designated constraints aren't met.
type CreatePoolRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePoolRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePoolRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePoolRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePoolRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePoolRequestValidationError) ErrorName() string {
	return "CreatePoolRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePoolRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePoolRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePoolRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePoolRequestValidationError{}

// Validate checks the field values on CreatePoolResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatePoolResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePoolResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePoolResponseMultiError, or nil if none found.
func (m *CreatePoolResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePoolResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	if len(errors) > 0 {
		return CreatePoolResponseMultiError(errors)
	}

	return nil
}

// CreatePoolResponseMultiError is an error wrapping multiple validation errors
// returned by CreatePoolResponse.ValidateAll() if the designated constraints
// aren't met.
type CreatePoolResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePoolResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePoolResponseMultiError) AllErrors() []error { return m }

// CreatePoolResponseValidationError is the validation error returned by
// CreatePoolResponse.Validate if the designated constraints aren't met.
type CreatePoolResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePoolResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePoolResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePoolResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePoolResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePoolResponseValidationError) ErrorName() string {
	return "CreatePoolResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePoolResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePoolResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePoolResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePoolResponseValidationError{}

// Validate checks the field values on GetPoolRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetPoolRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPoolRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetPoolRequestMultiError,
// or nil if none found.
func (m *GetPoolRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPoolRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetPoolRequestValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetPoolRequestValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetPoolRequestValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetPoolRequestMultiError(errors)
	}

	return nil
}

// GetPoolRequestMultiError is an error wrapping multiple validation errors
// returned by GetPoolRequest.ValidateAll() if the designated constraints
// aren't met.
type GetPoolRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPoolRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPoolRequestMultiError) AllErrors() []error { return m }

// GetPoolRequestValidationError is the validation error returned by
// GetPoolRequest.Validate if the designated constraints aren't met.
type GetPoolRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPoolRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPoolRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPoolRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPoolRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPoolRequestValidationError) ErrorName() string { return "GetPoolRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetPoolRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPoolRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPoolRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPoolRequestValidationError{}

// Validate checks the field values on GetPoolResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetPoolResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPoolResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPoolResponseMultiError, or nil if none found.
func (m *GetPoolResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPoolResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetPool()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetPoolResponseValidationError{
					field:  "Pool",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetPoolResponseValidationError{
					field:  "Pool",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPool()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetPoolResponseValidationError{
				field:  "Pool",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetPoolResponseMultiError(errors)
	}

	return nil
}

// GetPoolResponseMultiError is an error wrapping multiple validation errors
// returned by GetPoolResponse.ValidateAll() if the designated constraints
// aren't met.
type GetPoolResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPoolResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPoolResponseMultiError) AllErrors() []error { return m }

// GetPoolResponseValidationError is the validation error returned by
// GetPoolResponse.Validate if the designated constraints aren't met.
type GetPoolResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPoolResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPoolResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPoolResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPoolResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPoolResponseValidationError) ErrorName() string { return "GetPoolResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetPoolResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPoolResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPoolResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPoolResponseValidationError{}

// Validate checks the field values on GetPagedPoolsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetPagedPoolsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPagedPoolsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPagedPoolsRequestMultiError, or nil if none found.
func (m *GetPagedPoolsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPagedPoolsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetQueryOptions() == nil {
		err := GetPagedPoolsRequestValidationError{
			field:  "QueryOptions",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetQueryOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetPagedPoolsRequestValidationError{
					field:  "QueryOptions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetPagedPoolsRequestValidationError{
					field:  "QueryOptions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueryOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetPagedPoolsRequestValidationError{
				field:  "QueryOptions",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetAuth() == nil {
		err := GetPagedPoolsRequestValidationError{
			field:  "Auth",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetPagedPoolsRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetPagedPoolsRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetPagedPoolsRequestValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetPagedPoolsRequestMultiError(errors)
	}

	return nil
}

// GetPagedPoolsRequestMultiError is an error wrapping multiple validation
// errors returned by GetPagedPoolsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetPagedPoolsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPagedPoolsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPagedPoolsRequestMultiError) AllErrors() []error { return m }

// GetPagedPoolsRequestValidationError is the validation error returned by
// GetPagedPoolsRequest.Validate if the designated constraints aren't met.
type GetPagedPoolsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPagedPoolsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPagedPoolsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPagedPoolsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPagedPoolsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPagedPoolsRequestValidationError) ErrorName() string {
	return "GetPagedPoolsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetPagedPoolsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPagedPoolsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPagedPoolsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPagedPoolsRequestValidationError{}

// Validate checks the field values on GetPagedPoolsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetPagedPoolsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPagedPoolsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPagedPoolsResponseMultiError, or nil if none found.
func (m *GetPagedPoolsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPagedPoolsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	if len(m.GetPools()) > 1024 {
		err := GetPagedPoolsResponseValidationError{
			field:  "Pools",
			reason: "value must contain no more than 1024 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetPools() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetPagedPoolsResponseValidationError{
						field:  fmt.Sprintf("Pools[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetPagedPoolsResponseValidationError{
						field:  fmt.Sprintf("Pools[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetPagedPoolsResponseValidationError{
					field:  fmt.Sprintf("Pools[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetPagedPoolsResponseMultiError(errors)
	}

	return nil
}

// GetPagedPoolsResponseMultiError is an error wrapping multiple validation
// errors returned by GetPagedPoolsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetPagedPoolsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPagedPoolsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPagedPoolsResponseMultiError) AllErrors() []error { return m }

// GetPagedPoolsResponseValidationError is the validation error returned by
// GetPagedPoolsResponse.Validate if the designated constraints aren't met.
type GetPagedPoolsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPagedPoolsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPagedPoolsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPagedPoolsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPagedPoolsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPagedPoolsResponseValidationError) ErrorName() string {
	return "GetPagedPoolsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetPagedPoolsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPagedPoolsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPagedPoolsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPagedPoolsResponseValidationError{}

// Validate checks the field values on ResolvePoolRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResolvePoolRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResolvePoolRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResolvePoolRequestMultiError, or nil if none found.
func (m *ResolvePoolRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ResolvePoolRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() == nil {
		err := ResolvePoolRequestValidationError{
			field:  "Id",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResolvePoolRequestValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResolvePoolRequestValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResolvePoolRequestValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetResolution() == nil {
		err := ResolvePoolRequestValidationError{
			field:  "Resolution",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetResolution()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResolvePoolRequestValidationError{
					field:  "Resolution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResolvePoolRequestValidationError{
					field:  "Resolution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResolution()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResolvePoolRequestValidationError{
				field:  "Resolution",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetNewRendezvousSignature() == nil {
		err := ResolvePoolRequestValidationError{
			field:  "NewRendezvousSignature",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetNewRendezvousSignature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResolvePoolRequestValidationError{
					field:  "NewRendezvousSignature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResolvePoolRequestValidationError{
					field:  "NewRendezvousSignature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNewRendezvousSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResolvePoolRequestValidationError{
				field:  "NewRendezvousSignature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetAuth() == nil {
		err := ResolvePoolRequestValidationError{
			field:  "Auth",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResolvePoolRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResolvePoolRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResolvePoolRequestValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ResolvePoolRequestMultiError(errors)
	}

	return nil
}

// ResolvePoolRequestMultiError is an error wrapping multiple validation errors
// returned by ResolvePoolRequest.ValidateAll() if the designated constraints
// aren't met.
type ResolvePoolRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResolvePoolRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResolvePoolRequestMultiError) AllErrors() []error { return m }

// ResolvePoolRequestValidationError is the validation error returned by
// ResolvePoolRequest.Validate if the designated constraints aren't met.
type ResolvePoolRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResolvePoolRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResolvePoolRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResolvePoolRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResolvePoolRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResolvePoolRequestValidationError) ErrorName() string {
	return "ResolvePoolRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ResolvePoolRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResolvePoolRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResolvePoolRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResolvePoolRequestValidationError{}

// Validate checks the field values on ResolvePoolResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResolvePoolResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResolvePoolResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResolvePoolResponseMultiError, or nil if none found.
func (m *ResolvePoolResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ResolvePoolResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	if len(errors) > 0 {
		return ResolvePoolResponseMultiError(errors)
	}

	return nil
}

// ResolvePoolResponseMultiError is an error wrapping multiple validation
// errors returned by ResolvePoolResponse.ValidateAll() if the designated
// constraints aren't met.
type ResolvePoolResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResolvePoolResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResolvePoolResponseMultiError) AllErrors() []error { return m }

// ResolvePoolResponseValidationError is the validation error returned by
// ResolvePoolResponse.Validate if the designated constraints aren't met.
type ResolvePoolResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResolvePoolResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResolvePoolResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResolvePoolResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResolvePoolResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResolvePoolResponseValidationError) ErrorName() string {
	return "ResolvePoolResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ResolvePoolResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResolvePoolResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResolvePoolResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResolvePoolResponseValidationError{}

// Validate checks the field values on MakeBetRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MakeBetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MakeBetRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MakeBetRequestMultiError,
// or nil if none found.
func (m *MakeBetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MakeBetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPoolId() == nil {
		err := MakeBetRequestValidationError{
			field:  "PoolId",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPoolId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MakeBetRequestValidationError{
					field:  "PoolId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MakeBetRequestValidationError{
					field:  "PoolId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPoolId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MakeBetRequestValidationError{
				field:  "PoolId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetBet() == nil {
		err := MakeBetRequestValidationError{
			field:  "Bet",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetBet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MakeBetRequestValidationError{
					field:  "Bet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MakeBetRequestValidationError{
					field:  "Bet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MakeBetRequestValidationError{
				field:  "Bet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetRendezvousSignature() == nil {
		err := MakeBetRequestValidationError{
			field:  "RendezvousSignature",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetRendezvousSignature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MakeBetRequestValidationError{
					field:  "RendezvousSignature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MakeBetRequestValidationError{
					field:  "RendezvousSignature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRendezvousSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MakeBetRequestValidationError{
				field:  "RendezvousSignature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetAuth() == nil {
		err := MakeBetRequestValidationError{
			field:  "Auth",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MakeBetRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MakeBetRequestValidationError{
					field:  "Auth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MakeBetRequestValidationError{
				field:  "Auth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MakeBetRequestMultiError(errors)
	}

	return nil
}

// MakeBetRequestMultiError is an error wrapping multiple validation errors
// returned by MakeBetRequest.ValidateAll() if the designated constraints
// aren't met.
type MakeBetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MakeBetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MakeBetRequestMultiError) AllErrors() []error { return m }

// MakeBetRequestValidationError is the validation error returned by
// MakeBetRequest.Validate if the designated constraints aren't met.
type MakeBetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MakeBetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MakeBetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MakeBetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MakeBetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MakeBetRequestValidationError) ErrorName() string { return "MakeBetRequestValidationError" }

// Error satisfies the builtin error interface
func (e MakeBetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMakeBetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MakeBetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MakeBetRequestValidationError{}

// Validate checks the field values on MakeBetResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MakeBetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MakeBetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MakeBetResponseMultiError, or nil if none found.
func (m *MakeBetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MakeBetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Result

	if len(errors) > 0 {
		return MakeBetResponseMultiError(errors)
	}

	return nil
}

// MakeBetResponseMultiError is an error wrapping multiple validation errors
// returned by MakeBetResponse.ValidateAll() if the designated constraints
// aren't met.
type MakeBetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MakeBetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MakeBetResponseMultiError) AllErrors() []error { return m }

// MakeBetResponseValidationError is the validation error returned by
// MakeBetResponse.Validate if the designated constraints aren't met.
type MakeBetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MakeBetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MakeBetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MakeBetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MakeBetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MakeBetResponseValidationError) ErrorName() string { return "MakeBetResponseValidationError" }

// Error satisfies the builtin error interface
func (e MakeBetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMakeBetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MakeBetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MakeBetResponseValidationError{}
