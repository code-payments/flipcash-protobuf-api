// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file phone/v1/phone_verification_service.proto (package flipcash.phone.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { PhoneNumber, VerificationCode } from "./model_pb";
import { Auth } from "../../common/v1/common_pb";

/**
 * @generated from message flipcash.phone.v1.SendVerificationCodeRequest
 */
export class SendVerificationCodeRequest extends Message<SendVerificationCodeRequest> {
  /**
   * The phone number to send a verification code over SMS to.
   *
   * @generated from field: flipcash.phone.v1.PhoneNumber phone_number = 1;
   */
  phoneNumber?: PhoneNumber;

  /**
   * @generated from field: flipcash.common.v1.Auth auth = 2;
   */
  auth?: Auth;

  constructor(data?: PartialMessage<SendVerificationCodeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.phone.v1.SendVerificationCodeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "phone_number", kind: "message", T: PhoneNumber },
    { no: 2, name: "auth", kind: "message", T: Auth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendVerificationCodeRequest {
    return new SendVerificationCodeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendVerificationCodeRequest {
    return new SendVerificationCodeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendVerificationCodeRequest {
    return new SendVerificationCodeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SendVerificationCodeRequest | PlainMessage<SendVerificationCodeRequest> | undefined, b: SendVerificationCodeRequest | PlainMessage<SendVerificationCodeRequest> | undefined): boolean {
    return proto3.util.equals(SendVerificationCodeRequest, a, b);
  }
}

/**
 * @generated from message flipcash.phone.v1.SendVerificationCodeResponse
 */
export class SendVerificationCodeResponse extends Message<SendVerificationCodeResponse> {
  /**
   * @generated from field: flipcash.phone.v1.SendVerificationCodeResponse.Result result = 1;
   */
  result = SendVerificationCodeResponse_Result.OK;

  constructor(data?: PartialMessage<SendVerificationCodeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.phone.v1.SendVerificationCodeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(SendVerificationCodeResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendVerificationCodeResponse {
    return new SendVerificationCodeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendVerificationCodeResponse {
    return new SendVerificationCodeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendVerificationCodeResponse {
    return new SendVerificationCodeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SendVerificationCodeResponse | PlainMessage<SendVerificationCodeResponse> | undefined, b: SendVerificationCodeResponse | PlainMessage<SendVerificationCodeResponse> | undefined): boolean {
    return proto3.util.equals(SendVerificationCodeResponse, a, b);
  }
}

/**
 * @generated from enum flipcash.phone.v1.SendVerificationCodeResponse.Result
 */
export enum SendVerificationCodeResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * SMS is denied
   *
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,

  /**
   * SMS is rate limited (eg. by IP, phone number, user, etc) and was not sent.
   *
   * @generated from enum value: RATE_LIMITED = 2;
   */
  RATE_LIMITED = 2,

  /**
   * The phone number is not real because it fails Twilio lookup.
   *
   * @generated from enum value: INVALID_PHONE_NUMBER = 3;
   */
  INVALID_PHONE_NUMBER = 3,

  /**
   * The phone number is valid, but it maps to an unsupported type of phone
   * like a landline.
   *
   * @generated from enum value: UNSUPPORTED_PHONE_TYPE = 4;
   */
  UNSUPPORTED_PHONE_TYPE = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(SendVerificationCodeResponse_Result)
proto3.util.setEnumType(SendVerificationCodeResponse_Result, "flipcash.phone.v1.SendVerificationCodeResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
  { no: 2, name: "RATE_LIMITED" },
  { no: 3, name: "INVALID_PHONE_NUMBER" },
  { no: 4, name: "UNSUPPORTED_PHONE_TYPE" },
]);

/**
 * @generated from message flipcash.phone.v1.CheckVerificationCodeRequest
 */
export class CheckVerificationCodeRequest extends Message<CheckVerificationCodeRequest> {
  /**
   * The phone number being verified
   *
   * @generated from field: flipcash.phone.v1.PhoneNumber phone_number = 1;
   */
  phoneNumber?: PhoneNumber;

  /**
   * The verification code received via SMS
   *
   * @generated from field: flipcash.phone.v1.VerificationCode code = 2;
   */
  code?: VerificationCode;

  /**
   * @generated from field: flipcash.common.v1.Auth auth = 3;
   */
  auth?: Auth;

  constructor(data?: PartialMessage<CheckVerificationCodeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.phone.v1.CheckVerificationCodeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "phone_number", kind: "message", T: PhoneNumber },
    { no: 2, name: "code", kind: "message", T: VerificationCode },
    { no: 3, name: "auth", kind: "message", T: Auth },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckVerificationCodeRequest {
    return new CheckVerificationCodeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckVerificationCodeRequest {
    return new CheckVerificationCodeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckVerificationCodeRequest {
    return new CheckVerificationCodeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CheckVerificationCodeRequest | PlainMessage<CheckVerificationCodeRequest> | undefined, b: CheckVerificationCodeRequest | PlainMessage<CheckVerificationCodeRequest> | undefined): boolean {
    return proto3.util.equals(CheckVerificationCodeRequest, a, b);
  }
}

/**
 * @generated from message flipcash.phone.v1.CheckVerificationCodeResponse
 */
export class CheckVerificationCodeResponse extends Message<CheckVerificationCodeResponse> {
  /**
   * @generated from field: flipcash.phone.v1.CheckVerificationCodeResponse.Result result = 1;
   */
  result = CheckVerificationCodeResponse_Result.OK;

  constructor(data?: PartialMessage<CheckVerificationCodeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.phone.v1.CheckVerificationCodeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "enum", T: proto3.getEnumType(CheckVerificationCodeResponse_Result) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckVerificationCodeResponse {
    return new CheckVerificationCodeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckVerificationCodeResponse {
    return new CheckVerificationCodeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckVerificationCodeResponse {
    return new CheckVerificationCodeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CheckVerificationCodeResponse | PlainMessage<CheckVerificationCodeResponse> | undefined, b: CheckVerificationCodeResponse | PlainMessage<CheckVerificationCodeResponse> | undefined): boolean {
    return proto3.util.equals(CheckVerificationCodeResponse, a, b);
  }
}

/**
 * @generated from enum flipcash.phone.v1.CheckVerificationCodeResponse.Result
 */
export enum CheckVerificationCodeResponse_Result {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * @generated from enum value: DENIED = 1;
   */
  DENIED = 1,

  /**
   * The call is rate limited (eg. by IP, phone number, etc). The code is
   * not verified.
   *
   * @generated from enum value: RATE_LIMITED = 2;
   */
  RATE_LIMITED = 2,

  /**
   * The provided verification code is invalid. The user may retry
   * enterring the code if this is received. When max attempts are
   * received, NO_VERIFICATION will be returned.
   *
   * @generated from enum value: INVALID_CODE = 3;
   */
  INVALID_CODE = 3,

  /**
   * There is no verification in progress for the phone number. Several
   * reasons this can occur include a verification being expired or having
   * reached a maximum check threshold. The client must initiate a new
   * verification using SendVerificationCode.
   *
   * @generated from enum value: NO_VERIFICATION = 4;
   */
  NO_VERIFICATION = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(CheckVerificationCodeResponse_Result)
proto3.util.setEnumType(CheckVerificationCodeResponse_Result, "flipcash.phone.v1.CheckVerificationCodeResponse.Result", [
  { no: 0, name: "OK" },
  { no: 1, name: "DENIED" },
  { no: 2, name: "RATE_LIMITED" },
  { no: 3, name: "INVALID_CODE" },
  { no: 4, name: "NO_VERIFICATION" },
]);

