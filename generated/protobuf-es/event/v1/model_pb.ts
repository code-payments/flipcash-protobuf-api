// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file event/v1/model.proto (package flipcash.event.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { UserId } from "../../common/v1/common_pb";
import { BetSummary, PoolId, SignedPoolMetadata, UserPoolSummary } from "../../pool/v1/model_pb";

/**
 * @generated from message flipcash.event.v1.EventId
 */
export class EventId extends Message<EventId> {
  /**
   * @generated from field: bytes id = 1;
   */
  id = new Uint8Array(0);

  constructor(data?: PartialMessage<EventId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.event.v1.EventId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventId {
    return new EventId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventId {
    return new EventId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventId {
    return new EventId().fromJsonString(jsonString, options);
  }

  static equals(a: EventId | PlainMessage<EventId> | undefined, b: EventId | PlainMessage<EventId> | undefined): boolean {
    return proto3.util.equals(EventId, a, b);
  }
}

/**
 * todo: define additional events
 *
 * @generated from message flipcash.event.v1.Event
 */
export class Event extends Message<Event> {
  /**
   * @generated from field: flipcash.event.v1.EventId id = 1;
   */
  id?: EventId;

  /**
   * @generated from field: google.protobuf.Timestamp ts = 2;
   */
  ts?: Timestamp;

  /**
   * @generated from oneof flipcash.event.v1.Event.type
   */
  type: {
    /**
     * @generated from field: flipcash.event.v1.TestEvent test = 3;
     */
    value: TestEvent;
    case: "test";
  } | {
    /**
     * @generated from field: flipcash.event.v1.PoolResolvedEvent pool_resolved = 100;
     */
    value: PoolResolvedEvent;
    case: "poolResolved";
  } | {
    /**
     * @generated from field: flipcash.event.v1.PoolBetUpdateEvent pool_bet_update = 101;
     */
    value: PoolBetUpdateEvent;
    case: "poolBetUpdate";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Event>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.event.v1.Event";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: EventId },
    { no: 2, name: "ts", kind: "message", T: Timestamp },
    { no: 3, name: "test", kind: "message", T: TestEvent, oneof: "type" },
    { no: 100, name: "pool_resolved", kind: "message", T: PoolResolvedEvent, oneof: "type" },
    { no: 101, name: "pool_bet_update", kind: "message", T: PoolBetUpdateEvent, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Event {
    return new Event().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Event {
    return new Event().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Event {
    return new Event().fromJsonString(jsonString, options);
  }

  static equals(a: Event | PlainMessage<Event> | undefined, b: Event | PlainMessage<Event> | undefined): boolean {
    return proto3.util.equals(Event, a, b);
  }
}

/**
 * @generated from message flipcash.event.v1.EventBatch
 */
export class EventBatch extends Message<EventBatch> {
  /**
   * @generated from field: repeated flipcash.event.v1.Event events = 1;
   */
  events: Event[] = [];

  constructor(data?: PartialMessage<EventBatch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.event.v1.EventBatch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "events", kind: "message", T: Event, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventBatch {
    return new EventBatch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventBatch {
    return new EventBatch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventBatch {
    return new EventBatch().fromJsonString(jsonString, options);
  }

  static equals(a: EventBatch | PlainMessage<EventBatch> | undefined, b: EventBatch | PlainMessage<EventBatch> | undefined): boolean {
    return proto3.util.equals(EventBatch, a, b);
  }
}

/**
 * @generated from message flipcash.event.v1.UserEvent
 */
export class UserEvent extends Message<UserEvent> {
  /**
   * @generated from field: flipcash.common.v1.UserId user_id = 1;
   */
  userId?: UserId;

  /**
   * @generated from field: flipcash.event.v1.Event event = 2;
   */
  event?: Event;

  constructor(data?: PartialMessage<UserEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.event.v1.UserEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user_id", kind: "message", T: UserId },
    { no: 2, name: "event", kind: "message", T: Event },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserEvent {
    return new UserEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserEvent {
    return new UserEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserEvent {
    return new UserEvent().fromJsonString(jsonString, options);
  }

  static equals(a: UserEvent | PlainMessage<UserEvent> | undefined, b: UserEvent | PlainMessage<UserEvent> | undefined): boolean {
    return proto3.util.equals(UserEvent, a, b);
  }
}

/**
 * @generated from message flipcash.event.v1.UserEventBatch
 */
export class UserEventBatch extends Message<UserEventBatch> {
  /**
   * @generated from field: repeated flipcash.event.v1.UserEvent events = 1;
   */
  events: UserEvent[] = [];

  constructor(data?: PartialMessage<UserEventBatch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.event.v1.UserEventBatch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "events", kind: "message", T: UserEvent, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserEventBatch {
    return new UserEventBatch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserEventBatch {
    return new UserEventBatch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserEventBatch {
    return new UserEventBatch().fromJsonString(jsonString, options);
  }

  static equals(a: UserEventBatch | PlainMessage<UserEventBatch> | undefined, b: UserEventBatch | PlainMessage<UserEventBatch> | undefined): boolean {
    return proto3.util.equals(UserEventBatch, a, b);
  }
}

/**
 * @generated from message flipcash.event.v1.TestEvent
 */
export class TestEvent extends Message<TestEvent> {
  /**
   * @generated from field: repeated string hops = 1;
   */
  hops: string[] = [];

  /**
   * @generated from field: uint64 nonce = 2;
   */
  nonce = protoInt64.zero;

  constructor(data?: PartialMessage<TestEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.event.v1.TestEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hops", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestEvent {
    return new TestEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestEvent {
    return new TestEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestEvent {
    return new TestEvent().fromJsonString(jsonString, options);
  }

  static equals(a: TestEvent | PlainMessage<TestEvent> | undefined, b: TestEvent | PlainMessage<TestEvent> | undefined): boolean {
    return proto3.util.equals(TestEvent, a, b);
  }
}

/**
 * Event sent when a pool has been resolved
 *
 * @generated from message flipcash.event.v1.PoolResolvedEvent
 */
export class PoolResolvedEvent extends Message<PoolResolvedEvent> {
  /**
   * The latest signed pool metadata, which is guaranteed to contain a resolution
   *
   * @generated from field: flipcash.pool.v1.SignedPoolMetadata pool = 1;
   */
  pool?: SignedPoolMetadata;

  /**
   * The final bet summary for the pool
   *
   * @generated from field: flipcash.pool.v1.BetSummary bet_summary = 2;
   */
  betSummary?: BetSummary;

  /**
   * The user's outcome for the pool
   *
   * @generated from field: flipcash.pool.v1.UserPoolSummary user_summary = 3;
   */
  userSummary?: UserPoolSummary;

  constructor(data?: PartialMessage<PoolResolvedEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.event.v1.PoolResolvedEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pool", kind: "message", T: SignedPoolMetadata },
    { no: 2, name: "bet_summary", kind: "message", T: BetSummary },
    { no: 3, name: "user_summary", kind: "message", T: UserPoolSummary },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PoolResolvedEvent {
    return new PoolResolvedEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PoolResolvedEvent {
    return new PoolResolvedEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PoolResolvedEvent {
    return new PoolResolvedEvent().fromJsonString(jsonString, options);
  }

  static equals(a: PoolResolvedEvent | PlainMessage<PoolResolvedEvent> | undefined, b: PoolResolvedEvent | PlainMessage<PoolResolvedEvent> | undefined): boolean {
    return proto3.util.equals(PoolResolvedEvent, a, b);
  }
}

/**
 * Event sent when a bet is made against a pool
 *
 * @generated from message flipcash.event.v1.PoolBetUpdateEvent
 */
export class PoolBetUpdateEvent extends Message<PoolBetUpdateEvent> {
  /**
   * The pool ID the bet update is for
   *
   * @generated from field: flipcash.pool.v1.PoolId pool_id = 1;
   */
  poolId?: PoolId;

  /**
   * The latest bet summary for the pool
   *
   * @generated from field: flipcash.pool.v1.BetSummary bet_summary = 2;
   */
  betSummary?: BetSummary;

  constructor(data?: PartialMessage<PoolBetUpdateEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.event.v1.PoolBetUpdateEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pool_id", kind: "message", T: PoolId },
    { no: 2, name: "bet_summary", kind: "message", T: BetSummary },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PoolBetUpdateEvent {
    return new PoolBetUpdateEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PoolBetUpdateEvent {
    return new PoolBetUpdateEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PoolBetUpdateEvent {
    return new PoolBetUpdateEvent().fromJsonString(jsonString, options);
  }

  static equals(a: PoolBetUpdateEvent | PlainMessage<PoolBetUpdateEvent> | undefined, b: PoolBetUpdateEvent | PlainMessage<PoolBetUpdateEvent> | undefined): boolean {
    return proto3.util.equals(PoolBetUpdateEvent, a, b);
  }
}

/**
 * @generated from message flipcash.event.v1.ServerPing
 */
export class ServerPing extends Message<ServerPing> {
  /**
   * Timestamp the ping was sent on the stream, for client to get a sense
   * of potential network latency
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * The delay server will apply before sending the next ping
   *
   * @generated from field: google.protobuf.Duration ping_delay = 2;
   */
  pingDelay?: Duration;

  constructor(data?: PartialMessage<ServerPing>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.event.v1.ServerPing";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "message", T: Timestamp },
    { no: 2, name: "ping_delay", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerPing {
    return new ServerPing().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerPing {
    return new ServerPing().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerPing {
    return new ServerPing().fromJsonString(jsonString, options);
  }

  static equals(a: ServerPing | PlainMessage<ServerPing> | undefined, b: ServerPing | PlainMessage<ServerPing> | undefined): boolean {
    return proto3.util.equals(ServerPing, a, b);
  }
}

/**
 * @generated from message flipcash.event.v1.ClientPong
 */
export class ClientPong extends Message<ClientPong> {
  /**
   * Timestamp the Pong was sent on the stream, for server to get a sense
   * of potential network latency
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<ClientPong>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.event.v1.ClientPong";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientPong {
    return new ClientPong().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientPong {
    return new ClientPong().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientPong {
    return new ClientPong().fromJsonString(jsonString, options);
  }

  static equals(a: ClientPong | PlainMessage<ClientPong> | undefined, b: ClientPong | PlainMessage<ClientPong> | undefined): boolean {
    return proto3.util.equals(ClientPong, a, b);
  }
}

