// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file common/v1/common.proto (package flipcash.common.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from enum flipcash.common.v1.Platform
 */
export enum Platform {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: APPLE = 1;
   */
  APPLE = 1,

  /**
   * @generated from enum value: GOOGLE = 2;
   */
  GOOGLE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Platform)
proto3.util.setEnumType(Platform, "flipcash.common.v1.Platform", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "APPLE" },
  { no: 2, name: "GOOGLE" },
]);

/**
 * @generated from message flipcash.common.v1.PublicKey
 */
export class PublicKey extends Message<PublicKey> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<PublicKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.common.v1.PublicKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublicKey {
    return new PublicKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublicKey {
    return new PublicKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublicKey {
    return new PublicKey().fromJsonString(jsonString, options);
  }

  static equals(a: PublicKey | PlainMessage<PublicKey> | undefined, b: PublicKey | PlainMessage<PublicKey> | undefined): boolean {
    return proto3.util.equals(PublicKey, a, b);
  }
}

/**
 * @generated from message flipcash.common.v1.Signature
 */
export class Signature extends Message<Signature> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Signature>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.common.v1.Signature";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Signature {
    return new Signature().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Signature {
    return new Signature().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Signature {
    return new Signature().fromJsonString(jsonString, options);
  }

  static equals(a: Signature | PlainMessage<Signature> | undefined, b: Signature | PlainMessage<Signature> | undefined): boolean {
    return proto3.util.equals(Signature, a, b);
  }
}

/**
 * Auth provides an authentication information for RPCs/messages.
 *
 * Currently, only a single form is supported, but it may be useful in
 * the future to rely on session tokens instead.
 *
 * @generated from message flipcash.common.v1.Auth
 */
export class Auth extends Message<Auth> {
  /**
   * @generated from oneof flipcash.common.v1.Auth.kind
   */
  kind: {
    /**
     * KeyPair uses pub key cryptography to verify.
     *
     * @generated from field: flipcash.common.v1.Auth.KeyPair key_pair = 1;
     */
    value: Auth_KeyPair;
    case: "keyPair";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Auth>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.common.v1.Auth";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key_pair", kind: "message", T: Auth_KeyPair, oneof: "kind" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Auth {
    return new Auth().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Auth {
    return new Auth().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Auth {
    return new Auth().fromJsonString(jsonString, options);
  }

  static equals(a: Auth | PlainMessage<Auth> | undefined, b: Auth | PlainMessage<Auth> | undefined): boolean {
    return proto3.util.equals(Auth, a, b);
  }
}

/**
 * KeyPair uses a keypair to verify a message.
 *
 * The signature should be of the encapsulating proto message,
 * _without_ the Auth section being set.
 *
 * @generated from message flipcash.common.v1.Auth.KeyPair
 */
export class Auth_KeyPair extends Message<Auth_KeyPair> {
  /**
   * @generated from field: flipcash.common.v1.PublicKey pub_key = 1;
   */
  pubKey?: PublicKey;

  /**
   * @generated from field: flipcash.common.v1.Signature signature = 2;
   */
  signature?: Signature;

  constructor(data?: PartialMessage<Auth_KeyPair>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.common.v1.Auth.KeyPair";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pub_key", kind: "message", T: PublicKey },
    { no: 2, name: "signature", kind: "message", T: Signature },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Auth_KeyPair {
    return new Auth_KeyPair().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Auth_KeyPair {
    return new Auth_KeyPair().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Auth_KeyPair {
    return new Auth_KeyPair().fromJsonString(jsonString, options);
  }

  static equals(a: Auth_KeyPair | PlainMessage<Auth_KeyPair> | undefined, b: Auth_KeyPair | PlainMessage<Auth_KeyPair> | undefined): boolean {
    return proto3.util.equals(Auth_KeyPair, a, b);
  }
}

/**
 * @generated from message flipcash.common.v1.UserId
 */
export class UserId extends Message<UserId> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<UserId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.common.v1.UserId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserId {
    return new UserId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserId {
    return new UserId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserId {
    return new UserId().fromJsonString(jsonString, options);
  }

  static equals(a: UserId | PlainMessage<UserId> | undefined, b: UserId | PlainMessage<UserId> | undefined): boolean {
    return proto3.util.equals(UserId, a, b);
  }
}

/**
 * AppInstallId is a unque ID tied to a client app installation. It does not
 * identify a device. Value should remain private and not be shared across
 * installs.
 *
 * @generated from message flipcash.common.v1.AppInstallId
 */
export class AppInstallId extends Message<AppInstallId> {
  /**
   * @generated from field: string value = 1;
   */
  value = "";

  constructor(data?: PartialMessage<AppInstallId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.common.v1.AppInstallId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppInstallId {
    return new AppInstallId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppInstallId {
    return new AppInstallId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppInstallId {
    return new AppInstallId().fromJsonString(jsonString, options);
  }

  static equals(a: AppInstallId | PlainMessage<AppInstallId> | undefined, b: AppInstallId | PlainMessage<AppInstallId> | undefined): boolean {
    return proto3.util.equals(AppInstallId, a, b);
  }
}

/**
 * PaymentAmount defines an amount of USDC with currency exchange data
 *
 * @generated from message flipcash.common.v1.PaymentAmount
 */
export class PaymentAmount extends Message<PaymentAmount> {
  /**
   * ISO 4217 alpha-3 currency code the payment was made in
   *
   * @generated from field: string currency = 1;
   */
  currency = "";

  /**
   * The amount in the native currency that was paid
   *
   * @generated from field: double native_amount = 2;
   */
  nativeAmount = 0;

  /**
   * The amount in quarks of USDC that was paid
   *
   * @generated from field: uint64 quarks = 3;
   */
  quarks = protoInt64.zero;

  constructor(data?: PartialMessage<PaymentAmount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flipcash.common.v1.PaymentAmount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "native_amount", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "quarks", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaymentAmount {
    return new PaymentAmount().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaymentAmount {
    return new PaymentAmount().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaymentAmount {
    return new PaymentAmount().fromJsonString(jsonString, options);
  }

  static equals(a: PaymentAmount | PlainMessage<PaymentAmount> | undefined, b: PaymentAmount | PlainMessage<PaymentAmount> | undefined): boolean {
    return proto3.util.equals(PaymentAmount, a, b);
  }
}

